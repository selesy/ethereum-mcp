// Package generator writes JSONSchema method files, creates a Go embed
// for each one as well as a map of method name to schema source.
package generator

import (
	"context"
	"encoding/json"
	"log/slog"
	"os"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/selesy/ethereum-mcp/pkg/openrpc"
)

// Generator writes JSONSchema files and Go code for each OpenRPC method
// defined by the Ethereum execution APIs.
type Generator struct {
	log *slog.Logger
}

// New creates a new generator.
func New(log *slog.Logger) *Generator {
	return &Generator{
		log: log,
	}
}

// Run executes the Generator with the provided context and list of
// methods.
func (g *Generator) Run(ctx context.Context, methods []openrpc.Method) error {
	if err := os.Mkdir("data", 0o750); err != nil && !os.IsExist(err) {
		return err
	}

	f := jen.NewFile("schema")
	f.HeaderComment("Code generated by gen. DO NOT EDIT.")
	f.Anon("embed")

	dict := jen.Dict{}

	for _, method := range methods {
		goName := goName(method.Name())
		// Save the method schemas as formatted JSON files
		data, err := json.MarshalIndent(method, "", "  ")
		if err != nil {
			return err
		}

		if err := os.WriteFile(filepath.Join("data", method.Name()+".json"), data, 0o600); err != nil {
			return err
		}

		// Create an embed variable for each method
		f.Comment(goName + "JSON " + strings.ToLower(string(method.Description()[0])) + method.Description()[1:])
		f.Comment("//go:embed " + filepath.Join("data", method.Name()+".json"))
		f.Var().Id(goName).String()

		// Add the name/JSON to the lookup table
		dict[jen.Lit(method.Name())] = jen.Id(goName)
	}

	f.Comment("Schemas returns a map relating schema names to the associated Method.")
	f.Func().Id("Schemas").Params().Map(jen.String()).String().Block(
		jen.Return(jen.Map(jen.String()).String().Values(dict)),
	)

	if err := f.Save("schema_gen.go"); err != nil {
		return err
	}

	g.log.Info("Generated schema_gen.go")

	return nil
}

func goName(name string) string {
	tkns := strings.Split(name, "_")

	for i, tkn := range tkns {
		tkns[i] = strings.ToUpper(string(tkn[0])) + tkn[1:]
	}

	return strings.Join(tkns, "") + "JSON"
}
