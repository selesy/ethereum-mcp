// Package generator writes JSONSchema method files, creates a Go embed
// for each one as well as a map of method name to schema source.
package generator

import (
	"context"
	"encoding/json"
	"log/slog"
	"os"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/selesy/ethereum-mcp/pkg/openrpc"
)

// Generator writes JSONSchema files and Go code for each OpenRPC method
// defined by the Ethereum execution APIs.
type Generator struct {
	log *slog.Logger
}

// New creates a new generator.
func New(log *slog.Logger) *Generator {
	return &Generator{
		log: log,
	}
}

// Run executes the Generator with the provided context and list of
// methods.
func (g *Generator) Run(ctx context.Context, methods []openrpc.Method) error {
	if err := os.Mkdir(filepath.Join("schema", "data"), 0o750); err != nil && !os.IsExist(err) {
		return err
	}

	schemaFile := jen.NewFile("schema")
	schemaFile.HeaderComment("Code generated by /gen. DO NOT EDIT.")
	schemaFile.Anon("embed")
	schemaDict := jen.Dict{}

	if err := os.Mkdir("mcp", 0o750); err != nil && !os.IsExist(err) {
		return err
	}

	toolFile := jen.NewFile("mcp")
	toolFile.HeaderComment("Code generated by /gen. DO NOT EDIT.")
	toolDict := jen.Dict{}

	for _, method := range methods {
		goName := goName(method.Name())
		goDescr := goDescription(method.Description())

		// Save the method schemas as formatted JSON files
		data, err := json.MarshalIndent(method, "", "  ")
		if err != nil {
			return err
		}

		data = append(data, '\n')

		if err := os.WriteFile(filepath.Join("schema", "data", method.Name()+".json"), data, 0o600); err != nil {
			return err
		}

		// Create an embed variable for each method
		schemaFile.Comment(goName + "Schema " + goDescr)
		schemaFile.Comment("//go:embed " + filepath.Join("data", method.Name()+".json"))
		schemaFile.Var().Id(goName+"Schema").Qual("encoding/json", "RawMessage")

		// Add the name/json.RawMessage to the lookup table
		schemaDict[jen.Lit(method.Name())] = jen.Id(goName + "Schema")

		// Create a tool for the each method
		toolFile.Comment(goName + "Tool is an mcp.Tool that " + goDescr)
		toolFile.Var().Id(goName+"Tool").Op("=").Qual("github.com/mark3labs/mcp-go/mcp", "NewToolWithRawSchema").Call(
			jen.Lit(method.Name()),
			jen.Lit(method.Description()),
			jen.Qual("github.com/selesy/ethereum-mcp/pkg/schema", goName+"Schema"),
		)

		// Add the name/mcp.Tool to a lookup table
		toolDict[jen.Lit(method.Name())] = jen.Id(goName + "Tool")
	}

	schemaFile.Comment("Schemas returns a map relating method names to the associated JSONSchema.")
	schemaFile.Func().Id("Schemas").Params().Map(jen.String()).Qual("encoding/json", "RawMessage").Block(
		jen.Return(jen.Map(jen.String()).Qual("encoding/json", "RawMessage").Values(schemaDict)),
	)

	if err := schemaFile.Save(filepath.Join("schema", "schema_gen.go")); err != nil {
		return err
	}

	g.log.Info("Generated schema/schema_gen.go file")

	toolFile.Comment("Tools returns a map relating method names to the associated tool.")
	toolFile.Func().Id("Tools").Params().Map(jen.String()).Qual("github.com/mark3labs/mcp-go/mcp", "Tool").Block(
		jen.Return(jen.Map(jen.String()).Qual("github.com/mark3labs/mcp-go/mcp", "Tool").Values(toolDict)),
	)

	if err := toolFile.Save(filepath.Join("mcp", "tool_gen.go")); err != nil {
		return err
	}

	g.log.Info("Generated mcp/tool_gen.go file")

	return nil
}

func goName(name string) string {
	tkns := strings.Split(name, "_")

	for i, tkn := range tkns {
		tkns[i] = strings.ToUpper(string(tkn[0])) + tkn[1:]
	}

	return strings.Join(tkns, "")
}

func goDescription(descr string) string {
	return strings.ToLower(string(descr[0])) + descr[1:]
}
